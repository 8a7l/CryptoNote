<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>–î–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è —Ç–∞ AES-GCM —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è/—Ä–æ–∑—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è –∑ –∫—ñ–ª—å–∫–æ–º–∞ –º–∞—Ä–∫–µ—Ä–∞–º–∏</title>
  <style>
    body { font-family: sans-serif; max-width: 700px; margin: auto; padding: 20px; }
    textarea, input[type="text"], input[type="checkbox"] { width: 100%; margin-bottom: 10px; }
    button { margin: 5px 10px 5px 0; }
    .status { margin: 10px 0; font-weight: bold; }
    .success { color: green; }
    .error { color: red; }
  </style>
</head>
<body>
  <h2>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É, —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è/–¥–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è –∑ –∫—ñ–ª—å–∫–æ–º–∞ –º–∞—Ä–∫–µ—Ä–∞–º–∏ —Ç–∞ AES-GCM</h2>

  <label>–ö–ª—é—á (Base64 –∞–±–æ –ø–∞—Ä–æ–ª—å):</label>
  <input type="text" id="key">
  <button onclick="generateBase64Key()">üîë –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –∫–ª—é—á</button>

  <label><input type="checkbox" id="randomMarkers"> –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –≤–∏–ø–∞–¥–∫–æ–≤—ñ –º–∞—Ä–∫–µ—Ä–∏</label>

  <input type="file" id="fileInput">
  <button onclick="loadAndDecrypt()">–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —ñ —Ä–æ–∑—à–∏—Ñ—Ä—É–≤–∞—Ç–∏</button>

  <label>–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (–∞–±–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–µ Base64):</label>
  <textarea id="message" rows="4"></textarea>

  <div>
    <button onclick="encrypt()">üîí –ó–∞—à–∏—Ñ—Ä—É–≤–∞—Ç–∏</button>
    <button onclick="decrypt()">üîì –†–æ–∑—à–∏—Ñ—Ä—É–≤–∞—Ç–∏</button>
    <button onclick="downloadResult()">üíæ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
  </div>

  <label>–†–µ–∑—É–ª—å—Ç–∞—Ç:</label>
  <textarea id="result" rows="5" readonly></textarea>


  <div id="status" class="status"></div>

  <script>
    function showStatus(text, isError = false) {
      const status = document.getElementById("status");
      status.textContent = text;
      status.className = "status " + (isError ? "error" : "success");
    }

    async function generateBase64Key() {
      const key = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
      const raw = await crypto.subtle.exportKey("raw", key);
      document.getElementById("key").value = btoa(String.fromCharCode(...new Uint8Array(raw)));
      showStatus("–ó–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–æ –Ω–æ–≤–∏–π –∫–ª—é—á.");
    }

    async function getKeyFromInput() {
      const input = document.getElementById("key").value.trim();
      try {
        const raw = Uint8Array.from(atob(input), c => c.charCodeAt(0));
        return await crypto.subtle.importKey("raw", raw, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
      } catch {
        return deriveKeyFromPassword(input);
      }
    }

    async function deriveKeyFromPassword(password) {
      const enc = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
        "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt: new Uint8Array(16),
          iterations: 100000,
          hash: "SHA-256"
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

	async function loadAndDecrypt() {
	  const fileInput = document.getElementById("fileInput");
	  if (!fileInput.files.length) {
		alert("–û–±–µ—Ä—ñ—Ç—å —Ñ–∞–π–ª –¥–ª—è —Ä–æ–∑—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è.");
		return;
	  }

	  const reader = new FileReader();
	  reader.onload = async function (e) {
		const text = e.target.result;
		const regex = /\[([^\[\]]+)\]([\s\S]*?)\[\/\1\]/g;
		let result = "";
		let markers = [];
		let match;

		while ((match = regex.exec(text)) !== null) {
		  const marker = match[1];
		  markers.push(marker);

		  const b64 = match[2].trim();
		  try {
			const data = atob(b64);
			const combined = new Uint8Array([...data].map(c => c.charCodeAt(0)));
			const iv = combined.slice(0, 12);
			const encrypted = combined.slice(12);
			const key = await getKeyFromInput();
			const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encrypted);
			const decoder = new TextDecoder();
			result += `üîì [${marker}]: ${decoder.decode(decrypted)}\n\n`;
		  } catch (err) {
			result += `‚ùå [${marker}]: –ü–æ–º–∏–ª–∫–∞ –¥–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è.\n\n`;
		  }
		}

		document.getElementById("result").value = result;
	  };
	  reader.readAsText(fileInput.files[0]);
	}


    function generateRandomString(length) {
      const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      let result = "";
      for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * charset.length);
        result += charset[randomIndex];
      }
      return result;
    }

    async function encrypt() {
      try {
        const text = document.getElementById("message").value;
        const key = await getKeyFromInput();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encoder = new TextEncoder();
        const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoder.encode(text));
        const combined = new Uint8Array(iv.length + encrypted.byteLength);
        combined.set(iv);
        combined.set(new Uint8Array(encrypted), iv.length);

        let resultWithMarkers = '';
        if (document.getElementById("randomMarkers").checked) {
          const marker = generateRandomString(8); // –ì–µ–Ω–µ—Ä—É—î–º–æ –æ–¥–∏–Ω –º–∞—Ä–∫–µ—Ä
          resultWithMarkers = `[${marker}]${btoa(String.fromCharCode(...combined))}[/${marker}]`;
        } else {
          resultWithMarkers = btoa(String.fromCharCode(...combined));
        }

        document.getElementById("result").value = resultWithMarkers;
        await navigator.clipboard.writeText(resultWithMarkers);
        showStatus("‚úÖ –£—Å–ø—ñ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ —ñ —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ.");
      } catch (e) {
        showStatus("‚ùå –ü–æ–º–∏–ª–∫–∞ —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è.", true);
      }
    }

    function downloadResult() {
      const text = document.getElementById("result").value;
      if (!text) {
        showStatus("‚õî –ù–µ–º–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è.", true);
        return;
      }
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "result.txt";
      a.click();
      showStatus("‚úÖ –§–∞–π–ª –∑–±–µ—Ä–µ–∂–µ–Ω–æ.");
    }
	async function decrypt() {
	  try {
		const input = document.getElementById("message").value.trim();
		const key = await getKeyFromInput();
		const regex = /\[([^\[\]]+)\]([\s\S]*?)\[\/\1\]/g;
		let result = "";
		let match;
		let found = false;

		while ((match = regex.exec(input)) !== null) {
		  found = true;
		  try {
			const data = atob(match[2].trim());
			const combined = new Uint8Array([...data].map(c => c.charCodeAt(0)));
			const iv = combined.slice(0, 12);
			const encrypted = combined.slice(12);
			const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encrypted);
			const decoder = new TextDecoder();
			result += decoder.decode(decrypted) + "\n\n";
		  } catch {
			result += "‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–µ—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞.\n\n";
		  }
		}

		if (!found) {
		  // –ü—Ä–æ–±—É—î–º–æ —è–∫ –∑–≤–∏—á–∞–π–Ω–∏–π Base64 –±–µ–∑ –º–∞—Ä–∫–µ—Ä—ñ–≤
		  const data = atob(input);
		  const combined = new Uint8Array([...data].map(c => c.charCodeAt(0)));
		  const iv = combined.slice(0, 12);
		  const encrypted = combined.slice(12);
		  const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encrypted);
		  const decoder = new TextDecoder();
		  result = decoder.decode(decrypted);
		}

		document.getElementById("result").value = result;
		showStatus("‚úÖ –£—Å–ø—ñ—à–Ω–æ —Ä–æ–∑—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ.");
	  } catch (err) {
		showStatus("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Ä–æ–∑—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—ñ.", true);
	  }
	}
	


  </script>
</body>
</html>
